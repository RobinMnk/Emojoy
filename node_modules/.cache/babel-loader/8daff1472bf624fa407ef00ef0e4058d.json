{"ast":null,"code":"import _slicedToArray from \"/Users/berzanmikaili/Developer/hackatum2019/hackaTUM2019/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/berzanmikaili/Developer/hackatum2019/hackaTUM2019/src/components/faceapi.tsx\";\nimport React, { Component } from 'react';\nimport { Row } from 'antd';\nimport * as faceapi from \"face-api.js\";\nconst centerStyle = {\n  justifyContent: 'space-around',\n  display: 'flex'\n};\n\n/** EXAMPLE USAGE:\n *  <FaceAPI\n *      setEmotion={em => handleEmotionChange(em)}\n *      onRunning={() => this.setState({ loading: false })}\n *  />\n */\nexport default class FaceAPI extends Component {\n  constructor(props) {\n    super(props);\n    this.webcamId = \"webcam\";\n    this.canvasId = \"overlay\";\n    this.state = {\n      ready: false,\n      started: false,\n      running: false\n    };\n  }\n\n  async loadModel() {\n    const MODEL_URL = '/models';\n    await faceapi.loadSsdMobilenetv1Model(MODEL_URL);\n    await faceapi.loadAgeGenderModel(MODEL_URL);\n    await faceapi.loadFaceExpressionModel(MODEL_URL);\n    this.setState({\n      ready: true\n    });\n    console.log(\"loaded models\");\n  }\n\n  async applyModel(videoElement, canvas) {\n    const detections = await faceapi.detectSingleFace(videoElement).withFaceExpressions();\n\n    if (!detections) {\n      console.log(\"Detections are undefined :-( Model is not ready yet?\");\n    } else {\n      if (!this.state.running) {\n        if (this.props.onRunning) {\n          this.props.onRunning();\n        }\n\n        this.setState({\n          running: true\n        });\n      }\n\n      const dims = faceapi.matchDimensions(canvas, videoElement, true);\n      const resizedResult = faceapi.resizeResults(detections, dims);\n\n      if (resizedResult) {\n        faceapi.draw.drawDetections(canvas, resizedResult);\n        faceapi.draw.drawFaceExpressions(canvas, resizedResult, 0.05);\n      }\n\n      let maxConfidenceEmotion = \"neutral\";\n      let confidence = 0.0;\n\n      for (let _ref of Object.entries(detections.expressions)) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        let emotion = _ref2[0];\n        let newConfidence = _ref2[1];\n\n        if (newConfidence > confidence) {\n          maxConfidenceEmotion = emotion;\n          confidence = newConfidence;\n        }\n      }\n\n      if (this.state.emotion !== maxConfidenceEmotion) {\n        this.setState({\n          emotion: maxConfidenceEmotion\n        });\n        this.props.setEmotion(maxConfidenceEmotion);\n      }\n\n      console.log(maxConfidenceEmotion);\n    }\n\n    setTimeout(() => this.applyModel(videoElement, canvas), 50);\n  }\n\n  async startModel() {\n    this.setState({\n      started: true\n    });\n\n    if (!this.state.ready) {\n      await this.loadModel();\n    }\n\n    const videoElement = document.getElementById(this.webcamId);\n    const canvas = document.getElementById(this.canvasId);\n    console.log(\"starting face detection loop\");\n    await this.applyModel(videoElement, canvas);\n  }\n\n  async componentDidMount() {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true\n    });\n    const video = document.getElementById(this.webcamId);\n    video.srcObject = stream;\n    video.play();\n\n    if (!this.state.started) {\n      this.startModel();\n    }\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      style: this.props.noCenter ? {} : centerStyle,\n      className: \"webcam-component\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 103\n      },\n      __self: this\n    }, React.createElement(Row, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 104\n      },\n      __self: this\n    }, React.createElement(\"video\", {\n      id: this.webcamId,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 105\n      },\n      __self: this\n    }), React.createElement(\"canvas\", {\n      style: {\n        position: \"absolute\",\n        top: \"0px\",\n        left: \"0px\"\n      },\n      id: this.canvasId,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 106\n      },\n      __self: this\n    })));\n  }\n\n}","map":{"version":3,"sources":["/Users/berzanmikaili/Developer/hackatum2019/hackaTUM2019/src/components/faceapi.tsx"],"names":["React","Component","Row","faceapi","centerStyle","justifyContent","display","FaceAPI","constructor","props","webcamId","canvasId","state","ready","started","running","loadModel","MODEL_URL","loadSsdMobilenetv1Model","loadAgeGenderModel","loadFaceExpressionModel","setState","console","log","applyModel","videoElement","canvas","detections","detectSingleFace","withFaceExpressions","onRunning","dims","matchDimensions","resizedResult","resizeResults","draw","drawDetections","drawFaceExpressions","maxConfidenceEmotion","confidence","Object","entries","expressions","emotion","newConfidence","setEmotion","setTimeout","startModel","document","getElementById","componentDidMount","stream","navigator","mediaDevices","getUserMedia","video","srcObject","play","render","noCenter","position","top","left"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Row } from 'antd';\n\nimport * as faceapi from \"face-api.js\";\n\nconst centerStyle = {\n    justifyContent: 'space-around',\n    display: 'flex'\n};\n\nexport type Emotion = 'neutral' | 'happy' | 'sad' | 'surprised' | 'angry' | 'disgusted' | 'fearful'\n\ninterface IProps {\n    setEmotion(em: Emotion): void;\n    onRunning?(): void;\n    noCenter?: boolean;\n}\n\ninterface IFaceAPIState {\n    ready: boolean;\n    running: boolean;\n    started: boolean;\n    emotion?: string;\n}\n\n/** EXAMPLE USAGE:\n *  <FaceAPI\n *      setEmotion={em => handleEmotionChange(em)}\n *      onRunning={() => this.setState({ loading: false })}\n *  />\n */\nexport default class FaceAPI extends Component<IProps, IFaceAPIState> {\n    webcamId: string = \"webcam\";\n    canvasId: string = \"overlay\";\n    constructor(props: Readonly<IProps>) {\n        super(props);\n        this.state = { ready: false, started: false, running: false };\n    }\n\n    async loadModel() {\n        const MODEL_URL = '/models';\n        await faceapi.loadSsdMobilenetv1Model(MODEL_URL);\n        await faceapi.loadAgeGenderModel(MODEL_URL);\n        await faceapi.loadFaceExpressionModel(MODEL_URL);\n        this.setState({ ready: true });\n        console.log(\"loaded models\")\n    }\n\n    async applyModel(videoElement: HTMLVideoElement, canvas: HTMLCanvasElement) {\n        const detections = await faceapi.detectSingleFace(videoElement).withFaceExpressions()\n        if (!detections) {\n            console.log(\"Detections are undefined :-( Model is not ready yet?\")\n        } else {\n            if(!this.state.running) {\n                if(this.props.onRunning){\n                    this.props.onRunning();\n                }\n                this.setState({running: true});\n            }\n            const dims = faceapi.matchDimensions(canvas, videoElement, true);\n            const resizedResult = faceapi.resizeResults(detections, dims);\n            if (resizedResult) {\n                faceapi.draw.drawDetections(canvas, resizedResult);\n                faceapi.draw.drawFaceExpressions(canvas, resizedResult, 0.05)\n            }\n            let maxConfidenceEmotion = \"neutral\";\n            let confidence = 0.0;\n            for (let [emotion, newConfidence] of Object.entries(detections.expressions)) {\n                if (newConfidence > confidence) {\n                    maxConfidenceEmotion = emotion;\n                    confidence = newConfidence;\n                }\n            }\n            if (this.state.emotion !== maxConfidenceEmotion) {\n                this.setState({ emotion: maxConfidenceEmotion });\n                this.props.setEmotion(maxConfidenceEmotion as Emotion);\n            }\n            console.log(maxConfidenceEmotion);\n        }\n        setTimeout(() => this.applyModel(videoElement, canvas), 50);\n    }\n\n    async startModel() {\n        this.setState({ started: true });\n        if (!this.state.ready) {\n            await this.loadModel();\n        }\n        const videoElement = document.getElementById(this.webcamId) as HTMLVideoElement\n        const canvas = document.getElementById(this.canvasId) as HTMLCanvasElement\n        console.log(\"starting face detection loop\")\n        await this.applyModel(videoElement, canvas);\n    }\n    async componentDidMount() {\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        const video = document.getElementById(this.webcamId) as HTMLMediaElement;\n        video.srcObject = stream;\n        video.play()\n        if (!this.state.started) {\n            this.startModel();\n        }\n    }\n    render() {\n        return <div style={this.props.noCenter ? {} : centerStyle} className={\"webcam-component\"}>\n            <Row>\n                <video id={this.webcamId}></video>\n                <canvas style={{ position: \"absolute\", top: \"0px\", left: \"0px\" }} id={this.canvasId}></canvas>\n            </Row>\n        </div>\n    }\n}\n"]},"metadata":{},"sourceType":"module"}